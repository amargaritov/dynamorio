diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..1d7ede2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+build/*
+*.sw?
diff --git a/build.sh b/build.sh
new file mode 100644
index 0000000..3555672
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,3 @@
+pushd $SIMULATOR_DIR/build
+make -j
+popd
diff --git a/clients/drcachesim/analysis_tool.h b/clients/drcachesim/analysis_tool.h
index daa3212..b36b1d3 100644
--- a/clients/drcachesim/analysis_tool.h
+++ b/clients/drcachesim/analysis_tool.h
@@ -85,6 +85,9 @@ public:
      */
     virtual bool
     process_memref(const memref_t &memref) = 0;
+
+    virtual std::pair<bool,bool>
+    process_memref(const memref_t &memref, bool changed) {return std::pair<bool,bool>(true, true);} ;
     /**
      * This routine reports the results of the trace analysis.
      * The return value indicates whether it was successful.
diff --git a/clients/drcachesim/common/options.cpp b/clients/drcachesim/common/options.cpp
index f853a9e..d650ff9 100644
--- a/clients/drcachesim/common/options.cpp
+++ b/clients/drcachesim/common/options.cpp
@@ -124,6 +124,11 @@ droption_t<std::string> op_LL_miss_file(
     "analysis be written to the specified file. Each hint is written in text format as a "
     "<program counter, stride, locality level> tuple.");
 
+droption_t<std::string> op_pt_dump_file(
+    DROPTION_SCOPE_FRONTEND, "pt_dump_file", "",
+    "Path for loading page table from",
+    "");
+
 droption_t<bool> op_L0_filter(
     DROPTION_SCOPE_CLIENT, "L0_filter", false,
     "Filter out zero-level hits during tracing",
diff --git a/clients/drcachesim/common/options.h b/clients/drcachesim/common/options.h
index df8b004..13e67b7 100644
--- a/clients/drcachesim/common/options.h
+++ b/clients/drcachesim/common/options.h
@@ -73,6 +73,7 @@ extern droption_t<unsigned int> op_L1D_assoc;
 extern droption_t<bytesize_t> op_LL_size;
 extern droption_t<unsigned int> op_LL_assoc;
 extern droption_t<std::string> op_LL_miss_file;
+extern droption_t<std::string> op_pt_dump_file; //Artemiy
 extern droption_t<bytesize_t> op_L0I_size;
 extern droption_t<bool> op_L0_filter;
 extern droption_t<bytesize_t> op_L0D_size;
diff --git a/clients/drcachesim/common/trace_entry.h b/clients/drcachesim/common/trace_entry.h
index 0d39620..c8a555a 100644
--- a/clients/drcachesim/common/trace_entry.h
+++ b/clients/drcachesim/common/trace_entry.h
@@ -71,6 +71,11 @@ typedef enum {
     TRACE_TYPE_READ,  /**< A data load. */
     TRACE_TYPE_WRITE, /**< A data store. */
 
+    TRACE_TYPE_PE1,  /**< A data load. */
+    TRACE_TYPE_PE2,  /**< A data load. */
+    TRACE_TYPE_PE3,  /**< A data load. */
+    TRACE_TYPE_PE4,  /**< A data load. */
+
     TRACE_TYPE_PREFETCH, /**< A general prefetch to the level 1 data cache. */
     // X86 specific prefetch
     TRACE_TYPE_PREFETCHT0,  /**< An x86 prefetch to all levels of the cache. */
@@ -279,6 +284,11 @@ struct _trace_entry_t {
         // The length of each instr in the instr bundle
         unsigned char length[sizeof(addr_t)];
     };
+    //union {
+    addr_t phys_addr; // 4/8 bytes: mem ref addr, instr pc, tid, pid, marker val
+    //    // The length of each instr in the instr bundle
+    //    unsigned char length[sizeof(addr_t)];
+    //};
 } END_PACKED_STRUCTURE;
 typedef struct _trace_entry_t trace_entry_t;
 
@@ -347,6 +357,10 @@ struct _offline_entry_t {
             uint64_t type : 3;
         } addr;
         struct {
+            uint64_t addr : 61;
+            uint64_t type : 3;
+        } phys_addr;
+        struct {
             // This describes the entire basic block.
             uint64_t modoffs : PC_MODOFFS_BITS;
             uint64_t modidx : PC_MODIDX_BITS;
diff --git a/clients/drcachesim/simulator/analyzer_interface.cpp b/clients/drcachesim/simulator/analyzer_interface.cpp
index db8b063..af2577a 100644
--- a/clients/drcachesim/simulator/analyzer_interface.cpp
+++ b/clients/drcachesim/simulator/analyzer_interface.cpp
@@ -101,6 +101,7 @@ get_cache_simulator_knobs()
     knobs->LL_size = op_LL_size.get_value();
     knobs->LL_assoc = op_LL_assoc.get_value();
     knobs->LL_miss_file = op_LL_miss_file.get_value();
+    knobs->pt_dump_filename = op_pt_dump_file.get_value(); //Artemiy
     knobs->replace_policy = op_replace_policy.get_value();
     knobs->data_prefetcher = op_data_prefetcher.get_value();
     knobs->skip_refs = op_skip_refs.get_value();
@@ -120,8 +121,27 @@ drmemtrace_analysis_tool_create()
         if (!config_file.empty()) {
             return cache_simulator_create(config_file);
         } else {
+            //Artemiy, read TLB params to tlb_knobs
+            tlb_simulator_knobs_t tlb_knobs;
+            tlb_knobs.num_cores = op_num_cores.get_value();
+            tlb_knobs.page_size = op_page_size.get_value();
+            tlb_knobs.TLB_L1I_entries = op_TLB_L1I_entries.get_value();
+            tlb_knobs.TLB_L1D_entries = op_TLB_L1D_entries.get_value();
+            tlb_knobs.TLB_L1I_assoc = op_TLB_L1I_assoc.get_value();
+            tlb_knobs.TLB_L1D_assoc = op_TLB_L1D_assoc.get_value();
+            tlb_knobs.TLB_L2_entries = op_TLB_L2_entries.get_value();
+            tlb_knobs.TLB_L2_assoc = op_TLB_L2_assoc.get_value();
+            tlb_knobs.TLB_replace_policy = op_TLB_replace_policy.get_value();
+            tlb_knobs.skip_refs = op_skip_refs.get_value();
+            tlb_knobs.warmup_refs = op_warmup_refs.get_value();
+            tlb_knobs.warmup_fraction = op_warmup_fraction.get_value();
+            tlb_knobs.sim_refs = op_sim_refs.get_value();
+            tlb_knobs.verbose = op_verbose.get_value();
+            tlb_knobs.cpu_scheduling = op_cpu_scheduling.get_value();
+
             cache_simulator_knobs_t *knobs = get_cache_simulator_knobs();
-            return cache_simulator_create(*knobs);
+            //Artemiy: pass tlb knobs to the cache simlator creator
+            return cache_simulator_create(*knobs, tlb_knobs);
         }
     } else if (op_simulator_type.get_value() == MISS_ANALYZER) {
         cache_simulator_knobs_t *knobs = get_cache_simulator_knobs();
diff --git a/clients/drcachesim/simulator/cache.cpp b/clients/drcachesim/simulator/cache.cpp
index 5316b82..9317d71 100644
--- a/clients/drcachesim/simulator/cache.cpp
+++ b/clients/drcachesim/simulator/cache.cpp
@@ -55,6 +55,11 @@ cache_t::init_blocks()
     }
 }
 
+bool
+cache_t::request(const memref_t &memref_ini, bool changed ) {
+return true;
+}
+
 void
 cache_t::request(const memref_t &memref_in)
 {
diff --git a/clients/drcachesim/simulator/cache.h b/clients/drcachesim/simulator/cache.h
index 8ceac93..da5ecf4 100644
--- a/clients/drcachesim/simulator/cache.h
+++ b/clients/drcachesim/simulator/cache.h
@@ -50,6 +50,8 @@ public:
          bool inclusive = false, const std::vector<caching_device_t *> &children = {});
     virtual void
     request(const memref_t &memref);
+    virtual bool
+    request(const memref_t &memref, bool changed );
     virtual void
     flush(const memref_t &memref);
 
diff --git a/clients/drcachesim/simulator/cache_miss_analyzer.cpp b/clients/drcachesim/simulator/cache_miss_analyzer.cpp
index 714ea5e..60ebc2c 100644
--- a/clients/drcachesim/simulator/cache_miss_analyzer.cpp
+++ b/clients/drcachesim/simulator/cache_miss_analyzer.cpp
@@ -153,7 +153,7 @@ cache_miss_analyzer_t::cache_miss_analyzer_t(const cache_simulator_knobs_t &knob
                                              unsigned int miss_count_threshold,
                                              double miss_frac_threshold,
                                              double confidence_threshold)
-    : cache_simulator_t(knobs)
+    : cache_simulator_t(knobs, *(new tlb_simulator_knobs_t())) //Artemiy: very dirty hack to remove incompatibility with the new version
 {
     if (!success) {
         return;
diff --git a/clients/drcachesim/simulator/cache_simulator.cpp b/clients/drcachesim/simulator/cache_simulator.cpp
index c938f8f..8feb750 100644
--- a/clients/drcachesim/simulator/cache_simulator.cpp
+++ b/clients/drcachesim/simulator/cache_simulator.cpp
@@ -49,10 +49,13 @@
 #include "cache_simulator.h"
 #include "droption.h"
 
+#include <cstdio>
+#include <inttypes.h>
+
 analysis_tool_t *
-cache_simulator_create(const cache_simulator_knobs_t &knobs)
+cache_simulator_create(const cache_simulator_knobs_t &knobs, const tlb_simulator_knobs_t &tlb_knobs)
 {
-    return new cache_simulator_t(knobs);
+    return new cache_simulator_t(knobs, tlb_knobs);
 }
 
 analysis_tool_t *
@@ -61,7 +64,7 @@ cache_simulator_create(const std::string &config_file)
     return new cache_simulator_t(config_file);
 }
 
-cache_simulator_t::cache_simulator_t(const cache_simulator_knobs_t &knobs_)
+cache_simulator_t::cache_simulator_t(const cache_simulator_knobs_t &knobs_, const tlb_simulator_knobs_t &tlb_knobs_)
     : simulator_t(knobs_.num_cores, knobs_.skip_refs, knobs_.warmup_refs,
                   knobs_.warmup_fraction, knobs_.sim_refs, knobs_.cpu_scheduling,
                   knobs_.verbose)
@@ -69,9 +72,43 @@ cache_simulator_t::cache_simulator_t(const cache_simulator_knobs_t &knobs_)
     , l1_icaches(NULL)
     , l1_dcaches(NULL)
     , is_warmed_up(false)
+// use default tlb_knobs
+//    , tlb_knobs(tlb_knobs_)
 {
     // XXX i#1703: get defaults from hardware being run on.
 
+    //Artemiy - add TLB
+    tlb_sim = tlb_simulator_create(tlb_knobs_);
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-result" 
+    //load page_table
+    FILE* page_table_file = fopen(knobs.pt_dump_filename.c_str(),"r");
+    //read page_table size (in records)
+    int page_table_record_num = 0;
+    fscanf(page_table_file, "%d\n", &page_table_record_num);
+    std::cerr << "Loading page table with " <<  page_table_record_num << " PT entries...\n";
+    //std::cout << page_table_file << "\n";
+    for (int i = 0; i < page_table_record_num; i++) {
+      page_table_info_t tmp;
+      //fscanf(page_table_file, "%" SCNd64 ",%" SCNd64 ",%" SCNd64 ",%" SCNd64 ",%" SCNd64 ",%" SCNd64 "\n", &(tmp.VA), &(tmp.PE1), &(tmp.PE2), &(tmp.PE3), &(tmp.PE4), &(tmp.PA));
+      fscanf(page_table_file, "%x,%x,%x,%x,%x,%x\n", &(tmp.VA), &(tmp.PE1), &(tmp.PE2), &(tmp.PE3), &(tmp.PE4), &(tmp.PA));
+      //debug
+      //std::cout << "VA: " << tmp.VA << ", PA: " << tmp.PA << "\n";
+      page_table.insert(std::make_pair(tmp.VA, tmp));
+    }
+    std::cerr << "Loaded " << page_table.size() << " unique PT entries.\n";
+    fclose(page_table_file);
+#pragma GCC diagnostic pop 
+
+//    for(page_table_t::const_iterator it = page_table.begin();
+//    it != page_table.end(); ++it)
+//    {
+//      std::cout << it->first << " " << it->second.VA << " " << it->second.PA << "\n";
+//    }
+
+    //*********************************************************
+
     // This configuration allows for one shared LLC only.
     cache_t *llc = create_cache(knobs.replace_policy);
     if (llc == NULL) {
@@ -289,9 +326,26 @@ cache_simulator_t::remaining_sim_refs() const
     return knobs.sim_refs;
 }
 
+std::pair<bool,bool>
+cache_simulator_t::process_memref(const memref_t &memref, bool changed) {
+return std::pair<bool,bool>(true,true);
+}
+
 bool
 cache_simulator_t::process_memref(const memref_t &memref)
 {
+    static uint64_t num_request = 0;
+    static uint64_t num_request_shifted = 0;
+    static uint64_t num_not_found = 0;
+    num_request++;
+    num_request_shifted++;
+
+    if ((num_request_shifted >> 15) > 0) {
+      num_request_shifted = 0;
+      print_results();
+    }
+      
+
     if (knobs.skip_refs > 0) {
         knobs.skip_refs--;
         return true;
@@ -334,52 +388,145 @@ cache_simulator_t::process_memref(const memref_t &memref)
         last_core = core;
     }
 
-    if (type_is_instr(memref.instr.type) ||
-        memref.instr.type == TRACE_TYPE_PREFETCH_INSTR) {
+    //Artemiy: add TLB
+    uint64_t addr;
+
+    uint64_t virtual_page_addr = 0;
+    uint64_t page_offset = 0;
+    uint64_t physical_page_addr = 0;
+    uint64_t instrs_type = 0;
+
+    if (type_is_instr(memref.instr.type) || memref.instr.type == TRACE_TYPE_PREFETCH_INSTR) {
+      addr = memref.instr.addr;
+      virtual_page_addr = memref.instr.addr >> 12;
+      page_offset = memref.instr.addr & ((1 << 12) - 1);
+      instrs_type = 1;
+    } else if (memref.data.type == TRACE_TYPE_READ || memref.data.type == TRACE_TYPE_WRITE || type_is_prefetch(memref.data.type)) {
+      addr = memref.data.addr;
+      virtual_page_addr = memref.data.addr >> 12;
+      page_offset = memref.data.addr & ((1 << 12) - 1);
+      instrs_type = 2;
+    }
+
+    memref_t new_memref = memref; 
+    page_table_t::iterator it = page_table.find(virtual_page_addr << 12);
+    // if found 
+    if (it != page_table.end()) {
+      
+      physical_page_addr = it->second.PA;
+
+      if (type_is_instr(new_memref.instr.type) || new_memref.instr.type == TRACE_TYPE_PREFETCH_INSTR) {
+        new_memref.instr.addr = physical_page_addr + page_offset;
+      } else if (new_memref.data.type == TRACE_TYPE_READ || new_memref.data.type == TRACE_TYPE_WRITE || type_is_prefetch(new_memref.data.type)) {
+        new_memref.data.addr  = physical_page_addr + page_offset;
+      }
+
+      //std::cerr << "Request \n"
+      //              << std::hex 
+      //              << "Addr " << addr << "\n"
+      //              << std::dec
+      //              << "num_requests : " << num_request << "\n" 
+      //            ;
+
+      //TLB request
+      std::pair<bool, bool> res = tlb_sim->process_memref(memref, true /*changeByArtemiy*/);
+      bool is_TLB_hit = res.second;
+
+      //std::cerr << "Done TLB check \n";
+
+      // process TLB miss
+      if (!is_TLB_hit) {
+        //std::cerr << "TLB miss \n";
+
+        // page walk
+        memref_t page_walk_memref; 
+
+        page_walk_memref.data.type = TRACE_TYPE_PE1;
+        page_walk_memref.data.addr = it->second.PE1  + (virtual_page_addr >> 27);
+        page_walk_memref.data.size = 1; 
+        l1_dcaches[core]->request(page_walk_memref);
+        //std::cerr << "Done walk PE1\n";
+
+        page_walk_memref.data.type = TRACE_TYPE_PE2;
+        page_walk_memref.data.addr = it->second.PE2  + ((virtual_page_addr >> 18) & ((1 << 9) - 1));
+        page_walk_memref.data.size = 1; 
+        l1_dcaches[core]->request(page_walk_memref);
+        //std::cerr << "Done walk PE2\n";
+
+        page_walk_memref.data.type = TRACE_TYPE_PE3;
+        page_walk_memref.data.addr = it->second.PE3  + ((virtual_page_addr >> 9)  & ((1 << 9) - 1));
+        page_walk_memref.data.size = 1; 
+        l1_dcaches[core]->request(page_walk_memref);
+        //std::cerr << "Done walk PE3\n";
+
+        page_walk_memref.data.type = TRACE_TYPE_PE4;
+        page_walk_memref.data.addr = it->second.PE4  +  (virtual_page_addr        & ((1 << 9) - 1));
+        page_walk_memref.data.size = 1; 
+        l1_dcaches[core]->request(page_walk_memref);
+        //std::cerr << "Done walk PE4\n";
+      }
+    } else { //(it != page_table.end()) 
+      num_not_found++;
+      //std::cerr << "Error: cannot find translation for \n"
+      //              << std::hex 
+      //              << "Type " << ((instrs_type == 1) ? "instr" : "data") << "\n"
+      //              << "Addr " << addr << "\n"
+      //              << "VAddr >> 12 : " << virtual_page_addr << "\n"
+      //              << "VAddr : " << (virtual_page_addr << 12) << "\n"
+      //              << std::dec
+      //              << "VAddr page_offset : " << page_offset << "\n"
+      //              << "num_requests : " << num_request << "\n" 
+      //              << "num_not_found : " << num_not_found << "\n" 
+      //              ;
+      return true;
+    }
+
+    if (type_is_instr(new_memref.instr.type) ||
+        new_memref.instr.type == TRACE_TYPE_PREFETCH_INSTR) {
         if (knobs.verbose >= 3) {
-            std::cerr << "::" << memref.data.pid << "." << memref.data.tid << ":: "
-                      << " @" << (void *)memref.instr.addr << " instr x"
-                      << memref.instr.size << "\n";
+            std::cerr << "::" << new_memref.data.pid << "." << new_memref.data.tid << ":: "
+                      << " @" << (void *)new_memref.instr.addr << " instr x"
+                      << new_memref.instr.size << "\n";
         }
-        l1_icaches[core]->request(memref);
-    } else if (memref.data.type == TRACE_TYPE_READ ||
-               memref.data.type == TRACE_TYPE_WRITE ||
+        l1_icaches[core]->request(new_memref);
+    } else if (new_memref.data.type == TRACE_TYPE_READ ||
+               new_memref.data.type == TRACE_TYPE_WRITE ||
                // We may potentially handle prefetches differently.
                // TRACE_TYPE_PREFETCH_INSTR is handled above.
-               type_is_prefetch(memref.data.type)) {
+               type_is_prefetch(new_memref.data.type)) {
         if (knobs.verbose >= 3) {
-            std::cerr << "::" << memref.data.pid << "." << memref.data.tid << ":: "
-                      << " @" << (void *)memref.data.pc << " "
-                      << trace_type_names[memref.data.type] << " "
-                      << (void *)memref.data.addr << " x" << memref.data.size << "\n";
+            std::cerr << "::" << new_memref.data.pid << "." << new_memref.data.tid << ":: "
+                      << " @" << (void *)new_memref.data.pc << " "
+                      << trace_type_names[new_memref.data.type] << " "
+                      << (void *)new_memref.data.addr << " x" << new_memref.data.size << "\n";
         }
-        l1_dcaches[core]->request(memref);
-    } else if (memref.flush.type == TRACE_TYPE_INSTR_FLUSH) {
+        l1_dcaches[core]->request(new_memref);
+    } else if (new_memref.flush.type == TRACE_TYPE_INSTR_FLUSH) {
         if (knobs.verbose >= 3) {
-            std::cerr << "::" << memref.data.pid << "." << memref.data.tid << ":: "
-                      << " @" << (void *)memref.data.pc << " iflush "
-                      << (void *)memref.data.addr << " x" << memref.data.size << "\n";
+            std::cerr << "::" << new_memref.data.pid << "." << new_memref.data.tid << ":: "
+                      << " @" << (void *)new_memref.data.pc << " iflush "
+                      << (void *)new_memref.data.addr << " x" << new_memref.data.size << "\n";
         }
-        l1_icaches[core]->flush(memref);
-    } else if (memref.flush.type == TRACE_TYPE_DATA_FLUSH) {
+        l1_icaches[core]->flush(new_memref);
+    } else if (new_memref.flush.type == TRACE_TYPE_DATA_FLUSH) {
         if (knobs.verbose >= 3) {
-            std::cerr << "::" << memref.data.pid << "." << memref.data.tid << ":: "
-                      << " @" << (void *)memref.data.pc << " dflush "
-                      << (void *)memref.data.addr << " x" << memref.data.size << "\n";
+            std::cerr << "::" << new_memref.data.pid << "." << new_memref.data.tid << ":: "
+                      << " @" << (void *)new_memref.data.pc << " dflush "
+                      << (void *)new_memref.data.addr << " x" << new_memref.data.size << "\n";
         }
-        l1_dcaches[core]->flush(memref);
-    } else if (memref.exit.type == TRACE_TYPE_THREAD_EXIT) {
-        handle_thread_exit(memref.exit.tid);
+        l1_dcaches[core]->flush(new_memref);
+    } else if (new_memref.exit.type == TRACE_TYPE_THREAD_EXIT) {
+        handle_thread_exit(new_memref.exit.tid);
         last_thread = 0;
-    } else if (memref.marker.type == TRACE_TYPE_INSTR_NO_FETCH) {
+    } else if (new_memref.marker.type == TRACE_TYPE_INSTR_NO_FETCH) {
         // Just ignore.
         if (knobs.verbose >= 3) {
-            std::cerr << "::" << memref.data.pid << "." << memref.data.tid << ":: "
-                      << " @" << (void *)memref.instr.addr << " non-fetched instr x"
-                      << memref.instr.size << "\n";
+            std::cerr << "::" << new_memref.data.pid << "." << new_memref.data.tid << ":: "
+                      << " @" << (void *)new_memref.instr.addr << " non-fetched instr x"
+                      << new_memref.instr.size << "\n";
         }
     } else {
-        error_string = "Unhandled memref type " + std::to_string(memref.data.type);
+        error_string = "Unhandled memref type " + std::to_string(new_memref.data.type);
         return false;
     }
 
@@ -443,6 +590,7 @@ cache_simulator_t::check_warmed_up()
 bool
 cache_simulator_t::print_results()
 {
+    tlb_sim->print_results();
     std::cerr << "Cache simulation results:\n";
     // Print core and associated L1 cache stats first.
     for (unsigned int i = 0; i < knobs.num_cores; i++) {
diff --git a/clients/drcachesim/simulator/cache_simulator.h b/clients/drcachesim/simulator/cache_simulator.h
index 06005ec..90d066f 100644
--- a/clients/drcachesim/simulator/cache_simulator.h
+++ b/clients/drcachesim/simulator/cache_simulator.h
@@ -41,13 +41,15 @@
 #include "cache_simulator_create.h"
 #include "cache_stats.h"
 #include "cache.h"
+#include <map>
+#include <unordered_map>
 
 class cache_simulator_t : public simulator_t {
 public:
     // This constructor is used when the cache hierarchy is configured
     // using a set of knobs. It assumes a 2-level cache hierarchy with
     // private L1 data and instruction caches and a shared LLC.
-    cache_simulator_t(const cache_simulator_knobs_t &knobs);
+    cache_simulator_t(const cache_simulator_knobs_t &knobs, const tlb_simulator_knobs_t &tlb_knobs);
 
     // This constructor is used when the arbitrary cache hierarchy is
     // defined in a configuration file.
@@ -56,6 +58,8 @@ public:
     virtual ~cache_simulator_t();
     virtual bool
     process_memref(const memref_t &memref);
+    virtual std::pair<bool,bool>
+    process_memref(const memref_t &memref, bool changed);
     virtual bool
     print_results();
 
@@ -77,6 +81,25 @@ protected:
     cache_t **l1_icaches;
     cache_t **l1_dcaches;
 
+    //Artemiy: add TLB
+    analysis_tool_t * tlb_sim;
+
+    struct page_table_info_t {
+      unsigned int VA;
+      unsigned int PE1;
+      unsigned int PE2;
+      unsigned int PE3;
+      unsigned int PE4;
+      unsigned int PA;
+    };
+      
+    //Artemiy: add TLB
+    //typedef std::map<unsigned int, page_table_info_t> page_table_t;
+    typedef std::unordered_map<unsigned int, page_table_info_t> page_table_t;
+    page_table_t page_table;
+    std::vector<uint64_t> hit_statistics;
+    std::vector<uint64_t> miss_statistics;
+
     // The following unordered maps map a cache's name to a pointer to it.
     std::unordered_map<std::string, cache_t *> llcaches;     // LLC(s)
     std::unordered_map<std::string, cache_t *> other_caches; // Non-L1, non-LLC caches
diff --git a/clients/drcachesim/simulator/cache_simulator_create.h b/clients/drcachesim/simulator/cache_simulator_create.h
index 1dd98f4..41408b4 100644
--- a/clients/drcachesim/simulator/cache_simulator_create.h
+++ b/clients/drcachesim/simulator/cache_simulator_create.h
@@ -37,6 +37,7 @@
 
 #include <string>
 #include "analysis_tool.h"
+#include "tlb_simulator_create.h"
 
 /**
  * @file drmemtrace/cache_simulator_create.h
@@ -67,6 +68,7 @@ struct cache_simulator_knobs_t {
         , sim_refs(1ULL << 63)
         , cpu_scheduling(false)
         , verbose(0)
+        , pt_dump_filename("")
     {
     }
     unsigned int num_cores;
@@ -86,11 +88,13 @@ struct cache_simulator_knobs_t {
     uint64_t sim_refs;
     bool cpu_scheduling;
     unsigned int verbose;
+    std::string pt_dump_filename;
 };
 
 /** Creates an instance of a cache simulator with a 2-level hierarchy. */
 analysis_tool_t *
-cache_simulator_create(const cache_simulator_knobs_t &knobs);
+//cache_simulator_create(const cache_simulator_knobs_t &knobs); //Artemiy
+cache_simulator_create(const cache_simulator_knobs_t &knobs, const tlb_simulator_knobs_t &tlb_knobs);
 
 /**
  * Creates an instance of a cache simulator using a cache hierarchy defined
diff --git a/clients/drcachesim/simulator/caching_device.cpp b/clients/drcachesim/simulator/caching_device.cpp
index 1643a7b..7be2b59 100644
--- a/clients/drcachesim/simulator/caching_device.cpp
+++ b/clients/drcachesim/simulator/caching_device.cpp
@@ -37,6 +37,8 @@
 #include "../common/utils.h"
 #include <assert.h>
 
+#include <iostream>
+
 caching_device_t::caching_device_t()
     : blocks(NULL)
     , stats(NULL)
@@ -94,6 +96,11 @@ caching_device_t::init(int associativity_, int block_size_, int num_blocks_,
     return true;
 }
 
+bool
+caching_device_t::request(const memref_t &memref_in, bool changed ) {
+return true;
+}
+
 void
 caching_device_t::request(const memref_t &memref_in)
 {
@@ -136,7 +143,6 @@ caching_device_t::request(const memref_t &memref_in)
                 break;
             }
         }
-
         if (way == associativity) {
             stats->access(memref, false /*miss*/);
             missed = true;
diff --git a/clients/drcachesim/simulator/caching_device.h b/clients/drcachesim/simulator/caching_device.h
index 36f82bb..b8b6b09 100644
--- a/clients/drcachesim/simulator/caching_device.h
+++ b/clients/drcachesim/simulator/caching_device.h
@@ -61,6 +61,8 @@ public:
     virtual ~caching_device_t();
     virtual void
     request(const memref_t &memref);
+    virtual bool
+    request(const memref_t &memref, bool);
     virtual void
     invalidate(const addr_t tag);
 
diff --git a/clients/drcachesim/simulator/caching_device_stats.cpp b/clients/drcachesim/simulator/caching_device_stats.cpp
index c87f34c..fef2a6a 100644
--- a/clients/drcachesim/simulator/caching_device_stats.cpp
+++ b/clients/drcachesim/simulator/caching_device_stats.cpp
@@ -30,6 +30,8 @@
  * DAMAGE.
  */
 
+#define PAGE_WALK_STAGES 4
+
 #include <assert.h>
 #include <iostream>
 #include <iomanip>
@@ -48,6 +50,9 @@ caching_device_stats_t::caching_device_stats_t(const std::string &miss_file,
     , warmup_enabled(warmup_enabled)
     , file(nullptr)
 {
+    hit_statistics.resize (PAGE_WALK_STAGES, 0);
+    miss_statistics.resize(PAGE_WALK_STAGES, 0);
+
     if (miss_file.empty()) {
         dump_misses = false;
     } else {
@@ -80,9 +85,42 @@ caching_device_stats_t::access(const memref_t &memref, bool hit)
 {
     // We assume we're single-threaded.
     // We're only computing miss rate so we just inc counters here.
-    if (hit)
+    if (hit) {
+        if (memref.data.type == TRACE_TYPE_PE1) {
+          hit_statistics[0]++;
+          return;
+        } 
+        if (memref.data.type == TRACE_TYPE_PE2) {
+          hit_statistics[1]++;
+          return;
+        } 
+        if (memref.data.type == TRACE_TYPE_PE3) {
+          hit_statistics[2]++;
+          return;
+        } 
+        if (memref.data.type == TRACE_TYPE_PE4) {
+          hit_statistics[3]++;
+          return;
+        } 
         num_hits++;
+    }
     else {
+        if (memref.data.type == TRACE_TYPE_PE1) {
+          miss_statistics[0]++;
+          return;
+        } 
+        if (memref.data.type == TRACE_TYPE_PE2) {
+          miss_statistics[1]++;
+          return;
+        } 
+        if (memref.data.type == TRACE_TYPE_PE3) {
+          miss_statistics[2]++;
+          return;
+        } 
+        if (memref.data.type == TRACE_TYPE_PE4) {
+          miss_statistics[3]++;
+          return;
+        } 
         num_misses++;
         if (dump_misses)
             dump_miss(memref);
@@ -135,6 +173,14 @@ caching_device_stats_t::print_counts(std::string prefix)
               << std::right << num_misses << std::endl;
     std::cerr << prefix << std::setw(18) << std::left << "Invalidations:" << std::setw(20)
               << std::right << num_inclusive_invalidates << std::endl;
+
+    for (uint i = 0; i < PAGE_WALK_STAGES; i++) {
+      std::cerr << prefix << std::setw(18) << std::left << "Hits PT level" << (i+1) << ":" << std::setw(20)
+                << std::right << hit_statistics[i] << std::endl;
+
+      std::cerr << prefix << std::setw(18) << std::left << "Misses PT level" << (i+1) << ":" << std::setw(20)
+                << std::right << miss_statistics[i] << std::endl;
+    }
 }
 
 void
@@ -189,6 +235,11 @@ caching_device_stats_t::reset()
     num_misses = 0;
     num_child_hits = 0;
     num_inclusive_invalidates = 0;
+
+    for (uint i = 0; i < PAGE_WALK_STAGES; i++) {
+      hit_statistics[i]  = 0;
+      miss_statistics[i] = 0;
+    }
 }
 
 void
diff --git a/clients/drcachesim/simulator/caching_device_stats.h b/clients/drcachesim/simulator/caching_device_stats.h
index da3b445..1b5c6a8 100644
--- a/clients/drcachesim/simulator/caching_device_stats.h
+++ b/clients/drcachesim/simulator/caching_device_stats.h
@@ -36,6 +36,8 @@
 #ifndef _CACHING_DEVICE_STATS_H_
 #define _CACHING_DEVICE_STATS_H_ 1
 
+#include <vector>
+
 #include <string>
 #include <stdint.h>
 #ifdef HAS_ZLIB
@@ -90,6 +92,9 @@ protected:
     virtual void
     dump_miss(const memref_t &memref);
 
+    std::vector<int_least64_t> hit_statistics;
+    std::vector<int_least64_t> miss_statistics;
+
     int_least64_t num_hits;
     int_least64_t num_misses;
     int_least64_t num_child_hits;
diff --git a/clients/drcachesim/simulator/cmd b/clients/drcachesim/simulator/cmd
new file mode 100644
index 0000000..d0ede9c
--- /dev/null
+++ b/clients/drcachesim/simulator/cmd
@@ -0,0 +1 @@
+sed -i "1i $(wc -l converted_page_dump | awk '{print $1}')" converted_page_dump
diff --git a/clients/drcachesim/simulator/simulator.cpp b/clients/drcachesim/simulator/simulator.cpp
index 7a5fbf9..d797f69 100644
--- a/clients/drcachesim/simulator/simulator.cpp
+++ b/clients/drcachesim/simulator/simulator.cpp
@@ -77,6 +77,11 @@ simulator_t::init_knobs(unsigned int num_cores, uint64_t skip_refs, uint64_t war
     }
 }
 
+std::pair<bool,bool>
+simulator_t::process_memref(const memref_t &memref, bool changed) {
+return std::pair<bool,bool>(true,true);
+}
+
 bool
 simulator_t::process_memref(const memref_t &memref)
 {
diff --git a/clients/drcachesim/simulator/simulator.h b/clients/drcachesim/simulator/simulator.h
index b71f323..66ec3e6 100644
--- a/clients/drcachesim/simulator/simulator.h
+++ b/clients/drcachesim/simulator/simulator.h
@@ -55,6 +55,9 @@ public:
     virtual bool
     process_memref(const memref_t &memref);
 
+    virtual std::pair<bool,bool>
+    process_memref(const memref_t &memref, bool changed);
+
 protected:
     // Initialize knobs. Success or failure is indicated by setting/resetting
     // the success variable.
diff --git a/clients/drcachesim/simulator/tlb.cpp b/clients/drcachesim/simulator/tlb.cpp
index 43b8483..af04a61 100644
--- a/clients/drcachesim/simulator/tlb.cpp
+++ b/clients/drcachesim/simulator/tlb.cpp
@@ -40,6 +40,7 @@ tlb_t::init_blocks()
     for (int i = 0; i < num_blocks; i++) {
         blocks[i] = new tlb_entry_t;
     }
+    //Artemiy add reading PT files
 }
 
 void
@@ -73,7 +74,7 @@ tlb_t::request(const memref_t &memref_in)
         if (parent != NULL)
             parent->get_stats()->child_access(memref_in, true);
         access_update(last_block_idx, last_way);
-        return;
+        return; 
     }
 
     memref = memref_in;
@@ -101,6 +102,9 @@ tlb_t::request(const memref_t &memref_in)
                 parent->get_stats()->child_access(memref, false);
                 parent->request(memref);
             }
+            else {
+            //Artemiy add page walk
+            }
 
             // XXX: do we need to handle TLB coherency?
 
@@ -123,3 +127,97 @@ tlb_t::request(const memref_t &memref_in)
         last_pid = pid;
     }
 }
+
+//Artemiy copypaste
+bool
+tlb_t::request(const memref_t &memref_in, bool changed)
+{
+    // XXX: any better way to derive caching_device_t::request?
+    // Since pid is needed in a lot of places from the beginning to the end,
+    // it might also not be a good way to write a lot of helper functions
+    // to isolate them.
+
+    // Unfortunately we need to make a copy for our loop so we can pass
+    // the right data struct to the parent and stats collectors.
+    memref_t memref;
+    // We support larger sizes to improve the IPC perf.
+    // This means that one memref could touch multiple blocks.
+    // We treat each block separately for statistics purposes.
+    addr_t final_addr = memref_in.data.addr + memref_in.data.size - 1 /*avoid overflow*/;
+    addr_t final_tag = compute_tag(final_addr);
+    addr_t tag = compute_tag(memref_in.data.addr);
+    memref_pid_t pid = memref_in.data.pid;
+
+    // Optimization: check last tag and pid if single-block
+    if (tag == final_tag && tag == last_tag && pid == last_pid) {
+        // Make sure last_tag and pid are properly in sync.
+        assert(
+            tag != TAG_INVALID &&
+            tag == get_caching_device_block(last_block_idx, last_way).tag &&
+            pid ==
+                ((tlb_entry_t &)get_caching_device_block(last_block_idx, last_way)).pid);
+        stats->access(memref_in, true /*hit*/);
+        if (parent != NULL)
+            parent->get_stats()->child_access(memref_in, true);
+        access_update(last_block_idx, last_way);
+        return true; //found
+    }
+
+    bool prepare_to_return = false;
+    memref = memref_in;
+    for (; tag <= final_tag; ++tag) {
+        int way;
+        int block_idx = compute_block_idx(tag);
+
+        if (tag + 1 <= final_tag)
+            memref.data.size = ((tag + 1) << block_size_bits) - memref.data.addr;
+
+        for (way = 0; way < associativity; ++way) {
+            if (get_caching_device_block(block_idx, way).tag == tag &&
+                ((tlb_entry_t &)get_caching_device_block(block_idx, way)).pid == pid) {
+                stats->access(memref, true /*hit*/);
+                if (parent != NULL)
+                    parent->get_stats()->child_access(memref, true);
+                prepare_to_return = true; //found
+                break;
+            }
+        }
+
+        if (way == associativity) {
+            stats->access(memref, false /*miss*/);
+            // If no parent we assume we get the data from main memory
+            bool result = false;
+            if (parent != NULL) {
+                parent->get_stats()->child_access(memref, false);
+                result = parent->request(memref, true);
+            }
+            if (!result)
+            {
+              //Artemiy add return translation not found in the TLBs
+              prepare_to_return = false;
+            }
+
+            // XXX: do we need to handle TLB coherency?
+
+            way = replace_which_way(block_idx);
+            get_caching_device_block(block_idx, way).tag = tag;
+            ((tlb_entry_t &)get_caching_device_block(block_idx, way)).pid = pid;
+        }
+
+        access_update(block_idx, way);
+
+        if (tag + 1 <= final_tag) {
+            addr_t next_addr = (tag + 1) << block_size_bits;
+            memref.data.addr = next_addr;
+            memref.data.size = final_addr - next_addr + 1 /*undo the -1*/;
+        }
+        // Optimization: remember last tag and pid
+        last_tag = tag;
+        last_way = way;
+        last_block_idx = block_idx;
+        last_pid = pid;
+
+        return prepare_to_return;
+    }
+    return prepare_to_return;
+}
diff --git a/clients/drcachesim/simulator/tlb.h b/clients/drcachesim/simulator/tlb.h
index 99bb265..fda80e2 100644
--- a/clients/drcachesim/simulator/tlb.h
+++ b/clients/drcachesim/simulator/tlb.h
@@ -45,6 +45,9 @@ public:
     virtual void
     request(const memref_t &memref);
 
+    bool
+    request(const memref_t &memref, bool changed);
+
 protected:
     virtual void
     init_blocks();
diff --git a/clients/drcachesim/simulator/tlb_simulator.cpp b/clients/drcachesim/simulator/tlb_simulator.cpp
index 870ca18..50c4044 100644
--- a/clients/drcachesim/simulator/tlb_simulator.cpp
+++ b/clients/drcachesim/simulator/tlb_simulator.cpp
@@ -44,6 +44,8 @@
 #include "tlb.h"
 #include "tlb_simulator.h"
 
+#include <utility> //Artemiy for procmem
+
 analysis_tool_t *
 tlb_simulator_create(const tlb_simulator_knobs_t &knobs)
 {
@@ -121,26 +123,31 @@ tlb_simulator_t::~tlb_simulator_t()
 }
 
 bool
-tlb_simulator_t::process_memref(const memref_t &memref)
+tlb_simulator_t::process_memref(const memref_t &memref) {
+return true;
+}
+
+std::pair<bool, bool>
+tlb_simulator_t::process_memref(const memref_t &memref, bool changed)
 {
     if (knobs.skip_refs > 0) {
         knobs.skip_refs--;
-        return true;
+        return std::pair<bool, bool>(true, true);
     }
 
     // The references after warmup and simulated ones are dropped.
     if (knobs.warmup_refs == 0 && knobs.sim_refs == 0)
-        return true;
+        return std::pair<bool, bool>(true, true);
 
     // Both warmup and simulated references are simulated.
 
     if (!simulator_t::process_memref(memref))
-        return false;
+        return std::pair<bool, bool>(true, true);
 
     if (memref.marker.type == TRACE_TYPE_MARKER) {
         // We ignore markers before we ask core_for_thread, to avoid asking
         // too early on a timestamp marker.
-        return true;
+        return std::pair<bool, bool>(true, true);
     }
 
     // We use a static scheduling of threads to cores, as it is
@@ -155,10 +162,12 @@ tlb_simulator_t::process_memref(const memref_t &memref)
         last_core = core;
     }
 
+    bool found = false;
+
     if (type_is_instr(memref.instr.type))
-        itlbs[core]->request(memref);
+        found = itlbs[core]->request(memref, true);
     else if (memref.data.type == TRACE_TYPE_READ || memref.data.type == TRACE_TYPE_WRITE)
-        dtlbs[core]->request(memref);
+        found = dtlbs[core]->request(memref, true);
     else if (memref.exit.type == TRACE_TYPE_THREAD_EXIT) {
         handle_thread_exit(memref.exit.tid);
         last_thread = 0;
@@ -170,7 +179,7 @@ tlb_simulator_t::process_memref(const memref_t &memref)
         // TLB simulator ignores prefetching, cache flushing, and markers
     } else {
         error_string = "Unhandled memref type " + std::to_string(memref.data.type);
-        return false;
+        return std::pair<bool, bool>(false, true);
     }
 
     if (knobs.verbose >= 3) {
@@ -194,7 +203,7 @@ tlb_simulator_t::process_memref(const memref_t &memref)
     } else {
         knobs.sim_refs--;
     }
-    return true;
+    return std::pair<bool, bool>(true, false);
 }
 
 bool
@@ -204,11 +213,11 @@ tlb_simulator_t::print_results()
     for (unsigned int i = 0; i < knobs.num_cores; i++) {
         print_core(i);
         if (thread_ever_counts[i] > 0) {
-            std::cerr << "  L1I stats:" << std::endl;
+            std::cerr << "  TLB-L1I stats:" << std::endl;
             itlbs[i]->get_stats()->print_stats("    ");
-            std::cerr << "  L1D stats:" << std::endl;
+            std::cerr << "  TLB-L1D stats:" << std::endl;
             dtlbs[i]->get_stats()->print_stats("    ");
-            std::cerr << "  LL stats:" << std::endl;
+            std::cerr << "  TLB-LL stats:" << std::endl;
             lltlbs[i]->get_stats()->print_stats("    ");
         }
     }
diff --git a/clients/drcachesim/simulator/tlb_simulator.h b/clients/drcachesim/simulator/tlb_simulator.h
index f797b4b..04e75ac 100644
--- a/clients/drcachesim/simulator/tlb_simulator.h
+++ b/clients/drcachesim/simulator/tlb_simulator.h
@@ -48,9 +48,13 @@ public:
     virtual ~tlb_simulator_t();
     virtual bool
     process_memref(const memref_t &memref);
+
     virtual bool
     print_results();
 
+    std::pair<bool,bool> 
+    process_memref(const memref_t &memref, bool changed); //Added by Artemiy
+
 protected:
     // Create a tlb_t object with a specific replacement policy.
     virtual tlb_t *
diff --git a/source.sh b/source.sh
new file mode 100755
index 0000000..28bedfb
--- /dev/null
+++ b/source.sh
@@ -0,0 +1,5 @@
+export SIMULATOR_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )" 
+alias build_simulator='. $SIMULATOR_DIR/build.sh'
+alias clean_simulator='. $SIMULATOR_DIR/clean.sh'
+alias generate_trace='. $SIMULATOR_DIR/generate_trace.sh'
+function run_simulator() { $SIMULATOR_DIR/build/bin64/drrun "$@"; }
