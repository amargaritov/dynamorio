diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..a007fea
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+build/*
diff --git a/README.md b/README.md
index a800aa4..7a5df9e 100644
--- a/README.md
+++ b/README.md
@@ -1,60 +1,37 @@
-# DynamoRIO
+1. Set up environment variables
+```bash
+source source.sh
+```
+
+2. Install/Build the tracer
+```bash
+./install.sh
+```
+
+3. Prepare the system: disable THP, enable page table dump module
+```bash
+sudo ./prepare_system.sh
+```
+
+4. Generate trace
+```bash
+    ENABLE_FILE=/tmp/$RANDOM
+    echo 0 > $ENABLE_FILE 
+    OUTPUT_DIR=<output dir>
+    APPLICATION=<application with its arguments>
+    generate_trace --output_dir=$OUTPUT_DIR --enabler_file=$ENABLE_FILE $APPLICATION & pid=$!
+    echo $pid > /proc/page_tables
+    #
+    #
+    sleep 30 # stub
+    # once the application is warmed up 
+    echo 1 > $ENABLE_FILE 
+    #
+    #
+    sleep 20 # another stub
+    # once the trace generation is done
+    cat /proc/page_tables > $OUTPUT_DIR/pt_dump_raw
+    cat $OUTPUT_DIR/pt_dump_raw | convert_raw_pt_to_simulator_readable > $OUTPUT_DIR/pt_dump
+    kill $pid
+```
 
-![DynamoRIO logo](http://www.burningcutlery.com/images/dynamorio/drlogo.png)
-
-## About DynamoRIO
-
-DynamoRIO is a runtime code manipulation system that supports code
-transformations on any part of a program, while it executes. DynamoRIO
-exports an interface for building dynamic tools for a wide variety of uses:
-program analysis and understanding, profiling, instrumentation,
-optimization, translation, etc. Unlike many dynamic tool systems, DynamoRIO
-is not limited to insertion of callouts/trampolines and allows arbitrary
-modifications to application instructions via a powerful IA-32/AMD64/ARM/AArch64
-instruction manipulation library. DynamoRIO provides efficient,
-transparent, and comprehensive manipulation of unmodified applications
-running on stock operating systems (Windows, Linux, or Android) and commodity
-IA-32, AMD64, ARM, and AArch64 hardware.  Mac OSX support is in progress.
-
-## Existing DynamoRIO-based tools
-
-Tools built on DynamoRIO and provided in our release package include:
-
-- The memory debugging tool [Dr. Memory](http://drmemory.org)
-- The multi-process cache simulator and memory address trace collection and
-  analysis platform [drcachesim](http://dynamorio.org/docs/page_drcachesim.html)
-- The legacy processor emulator
-  [drcpusim](http://dynamorio.org/docs/page_drcpusim.html)
-- The "strace for Windows" tool [drstrace](http://drmemory.org/strace_for_windows.html)
-- The code coverage tool [drcov](http://dynamorio.org/docs/page_drcov.html)
-- The library tracing tool [drltrace](https://github.com/DynamoRIO/drmemory/tree/master/drltrace)
-- The memory tracing tool [memtrace](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/memtrace_simple.c)
-- The basic block tracing tool [bbbuf](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/bbbuf.c)
-- The instruction counting tool [inscount](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/inscount.cpp)
-
-## Building your own custom tools
-
-DynamoRIO's powerful API abstracts away the details of the underlying
-infrastructure and allows the tool builder to concentrate on analyzing or
-modifying the application's runtime code stream.  API documentation is
-included in the release package and can also be [browsed
-online](http://dynamorio.org/docs/).  [Slides from our past tutorials are
-also available](https://github.com/DynamoRIO/dynamorio/wiki/Downloads).
-
-## Downloading DynamoRIO
-
-DynamoRIO is available free of charge as a [binary package for both Windows
-and Linux](https://github.com/DynamoRIO/dynamorio/wiki/Downloads).
-DynamoRIO's [source code is
-available](https://github.com/DynamoRIO/dynamorio) under a [BSD
-license](https://github.com/DynamoRIO/dynamorio/blob/master/License.txt).
-
-## Obtaining Help
-
-Use the [discussion list](http://groups.google.com/group/DynamoRIO-Users)
-to ask questions.
-
-To report a bug, use the [issue
-tracker](https://github.com/DynamoRIO/dynamorio/issues).
-
-See also [the DynamoRIO home page](http://dynamorio.org/): [http://dynamorio.org/](http://dynamorio.org/)
diff --git a/README.md_default b/README.md_default
new file mode 100644
index 0000000..a800aa4
--- /dev/null
+++ b/README.md_default
@@ -0,0 +1,60 @@
+# DynamoRIO
+
+![DynamoRIO logo](http://www.burningcutlery.com/images/dynamorio/drlogo.png)
+
+## About DynamoRIO
+
+DynamoRIO is a runtime code manipulation system that supports code
+transformations on any part of a program, while it executes. DynamoRIO
+exports an interface for building dynamic tools for a wide variety of uses:
+program analysis and understanding, profiling, instrumentation,
+optimization, translation, etc. Unlike many dynamic tool systems, DynamoRIO
+is not limited to insertion of callouts/trampolines and allows arbitrary
+modifications to application instructions via a powerful IA-32/AMD64/ARM/AArch64
+instruction manipulation library. DynamoRIO provides efficient,
+transparent, and comprehensive manipulation of unmodified applications
+running on stock operating systems (Windows, Linux, or Android) and commodity
+IA-32, AMD64, ARM, and AArch64 hardware.  Mac OSX support is in progress.
+
+## Existing DynamoRIO-based tools
+
+Tools built on DynamoRIO and provided in our release package include:
+
+- The memory debugging tool [Dr. Memory](http://drmemory.org)
+- The multi-process cache simulator and memory address trace collection and
+  analysis platform [drcachesim](http://dynamorio.org/docs/page_drcachesim.html)
+- The legacy processor emulator
+  [drcpusim](http://dynamorio.org/docs/page_drcpusim.html)
+- The "strace for Windows" tool [drstrace](http://drmemory.org/strace_for_windows.html)
+- The code coverage tool [drcov](http://dynamorio.org/docs/page_drcov.html)
+- The library tracing tool [drltrace](https://github.com/DynamoRIO/drmemory/tree/master/drltrace)
+- The memory tracing tool [memtrace](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/memtrace_simple.c)
+- The basic block tracing tool [bbbuf](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/bbbuf.c)
+- The instruction counting tool [inscount](https://github.com/DynamoRIO/dynamorio/blob/master/api/samples/inscount.cpp)
+
+## Building your own custom tools
+
+DynamoRIO's powerful API abstracts away the details of the underlying
+infrastructure and allows the tool builder to concentrate on analyzing or
+modifying the application's runtime code stream.  API documentation is
+included in the release package and can also be [browsed
+online](http://dynamorio.org/docs/).  [Slides from our past tutorials are
+also available](https://github.com/DynamoRIO/dynamorio/wiki/Downloads).
+
+## Downloading DynamoRIO
+
+DynamoRIO is available free of charge as a [binary package for both Windows
+and Linux](https://github.com/DynamoRIO/dynamorio/wiki/Downloads).
+DynamoRIO's [source code is
+available](https://github.com/DynamoRIO/dynamorio) under a [BSD
+license](https://github.com/DynamoRIO/dynamorio/blob/master/License.txt).
+
+## Obtaining Help
+
+Use the [discussion list](http://groups.google.com/group/DynamoRIO-Users)
+to ask questions.
+
+To report a bug, use the [issue
+tracker](https://github.com/DynamoRIO/dynamorio/issues).
+
+See also [the DynamoRIO home page](http://dynamorio.org/): [http://dynamorio.org/](http://dynamorio.org/)
diff --git a/build.sh b/build.sh
new file mode 100755
index 0000000..5b5c71e
--- /dev/null
+++ b/build.sh
@@ -0,0 +1,3 @@
+pushd $TRACER_DIR/build
+make -j
+popd
diff --git a/clean.sh b/clean.sh
new file mode 100644
index 0000000..04f7cdd
--- /dev/null
+++ b/clean.sh
@@ -0,0 +1,3 @@
+pushd $TRACER_DIR/build
+make clean 
+popd
diff --git a/clients/drcachesim/common/options.cpp b/clients/drcachesim/common/options.cpp
index f853a9e..485d5ba 100644
--- a/clients/drcachesim/common/options.cpp
+++ b/clients/drcachesim/common/options.cpp
@@ -188,6 +188,11 @@ droption_t<bytesize_t> op_trace_after_instrs(
     "executions are observed.  At that point, regular tracing is put into place.  Use "
     "-max_trace_size to set a limit on the subsequent trace length.");
 
+droption_t<std::string> op_enabler_filename(
+    DROPTION_SCOPE_CLIENT, "enabler_filename", "/tmp/default_file_enabler",
+    "Enabler file name",
+    "Specifies name of the file which should have 1 for tracer to start recording the trace");
+
 droption_t<bytesize_t> op_exit_after_tracing(
     DROPTION_SCOPE_CLIENT, "exit_after_tracing", 0,
     "Exit the process after tracing N references",
diff --git a/clients/drcachesim/common/options.h b/clients/drcachesim/common/options.h
index df8b004..3f1382b 100644
--- a/clients/drcachesim/common/options.h
+++ b/clients/drcachesim/common/options.h
@@ -81,6 +81,7 @@ extern droption_t<unsigned int> op_virt2phys_freq;
 extern droption_t<bool> op_cpu_scheduling;
 extern droption_t<bytesize_t> op_max_trace_size;
 extern droption_t<bytesize_t> op_trace_after_instrs;
+extern droption_t<std::string> op_enabler_filename; //Artemiy: add file name for enabling tracing
 extern droption_t<bytesize_t> op_exit_after_tracing;
 extern droption_t<bool> op_online_instr_types;
 extern droption_t<std::string> op_replace_policy;
diff --git a/clients/drcachesim/launcher.cpp b/clients/drcachesim/launcher.cpp
index fe87ca3..b783ec6 100644
--- a/clients/drcachesim/launcher.cpp
+++ b/clients/drcachesim/launcher.cpp
@@ -80,11 +80,14 @@ static analyzer_t *analyzer;
 static pid_t child;
 #endif
 
+static bool enabled;
+
 #ifdef UNIX
 static void
 signal_handler(int sig, siginfo_t *info, void *cxt)
 {
 #    define INTERRUPT_MSG "Interrupted: exiting.\n"
+    printf("catcher() has gained control\n");
     ssize_t res = write(STDERR_FILENO, INTERRUPT_MSG, sizeof(INTERRUPT_MSG));
     (void)res; // Work around compiler warnings.
     // Terminate child in case shell didn't already send this there.
@@ -195,6 +198,7 @@ _tmain(int argc, const TCHAR *targv[])
     int rc = sigaction(SIGINT, &act, NULL);
     if (rc != 0)
         NOTIFY(0, "WARNING", "Failed to set up interrupt handler\n");
+  
 #else
     // We do not bother with SetConsoleCtrlHandler for two reasons:
     // one, there's no problem to solve like the UNIX fifo file left
@@ -262,6 +266,7 @@ _tmain(int argc, const TCHAR *targv[])
         }
     }
 
+    enabled = false;
     if (op_offline.get_value() && !have_trace_file) {
         // Initial sanity check: may still be unwritable by this user, but this
         // serves as at least an existence check.
diff --git a/clients/drcachesim/tracer/tracer.cpp b/clients/drcachesim/tracer/tracer.cpp
index 334904a..6996da5 100644
--- a/clients/drcachesim/tracer/tracer.cpp
+++ b/clients/drcachesim/tracer/tracer.cpp
@@ -1,4 +1,4 @@
-/* ******************************************************************************
+  /* ******************************************************************************
  * Copyright (c) 2011-2018 Google, Inc.  All rights reserved.
  * Copyright (c) 2010 Massachusetts Institute of Technology  All rights reserved.
  * ******************************************************************************/
@@ -421,7 +421,8 @@ memtrace(void *drcontext, bool skip_size_cap)
                  mem_ref += instru->sizeof_entry()) {
                 trace_type_t type = instru->get_entry_type(mem_ref);
                 if (type != TRACE_TYPE_THREAD && type != TRACE_TYPE_THREAD_EXIT &&
-                    type != TRACE_TYPE_PID) {
+                    type != TRACE_TYPE_PID 
+                    && type != TRACE_TYPE_INSTR_BUNDLE) {
                     addr_t virt = instru->get_entry_addr(mem_ref);
                     addr_t phys = physaddr.virtual2physical(virt);
                     DR_ASSERT(type != TRACE_TYPE_INSTR_BUNDLE);
@@ -1252,11 +1253,12 @@ event_kernel_xfer(void *drcontext, const dr_kernel_xfer_info_t *info)
  */
 
 static uint64 instr_count;
+static uint64 fine_grained_check_instr_count;
 static volatile bool tracing_enabled;
 static void *enable_tracing_lock;
 
 #ifdef X86_64
-#    define DELAYED_CHECK_INLINED 1
+//#    define DELAYED_CHECK_INLINED 1 //Artemiy disable inlining to go to 
 #else
 // XXX: we don't have the inlining implemented yet.
 #endif
@@ -1330,13 +1332,37 @@ hit_instr_count_threshold()
         DR_ASSERT(false);
 }
 
+
 #ifndef DELAYED_CHECK_INLINED
 static void
 check_instr_count_threshold(uint incby)
 {
+// Clean code:
+//    instr_count += incby;
+//    if (instr_count > op_trace_after_instrs.get_value())
+//        hit_instr_count_threshold();
+
+//Artemiy: dirty hack: replace existing instr counter comparison with threshold with checking a file
     instr_count += incby;
-    if (instr_count > op_trace_after_instrs.get_value())
+    fine_grained_check_instr_count += incby;
+//    NOTIFY(0, "Inside check_ %d %d\n", instr_count, fine_grained_check_instr_count);
+    uint shift_size = 24;
+    
+    if ((fine_grained_check_instr_count >> shift_size) > 0) {
+      fine_grained_check_instr_count = 0;
+      //check file
+      FILE* enabler_file = fopen(op_enabler_filename.get_value().c_str(),"r");
+      int enabler_file_status = 0;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wunused-result" 
+      fscanf(enabler_file, "%d", &enabler_file_status);
+#pragma GCC diagnostic pop 
+      if (enabler_file_status) {
         hit_instr_count_threshold();
+      }
+      fclose(enabler_file);
+      fine_grained_check_instr_count = fine_grained_check_instr_count >> shift_size;
+    }
 }
 #endif
 
@@ -1606,7 +1632,7 @@ event_exit(void)
 
     dr_mutex_destroy(mutex);
     drutil_exit();
-    if (op_trace_after_instrs.get_value() > 0)
+    if ( (op_trace_after_instrs.get_value() > 0) || 1)  //Artemiy
         exit_delay_instrumentation();
     drmgr_exit();
     func_trace_exit();
diff --git a/cmd_test b/cmd_test
new file mode 100644
index 0000000..41088a3
--- /dev/null
+++ b/cmd_test
@@ -0,0 +1,2 @@
+source /disk/memphis/data/s1470894/neuralwalkers/workloads/mcf/source.sh
+run_tracer -t drcachesim -offline -verbose 1 -enabler_filename /tmp/enabler_filename -trace_after_instrs 1 -- $MCF_DIR/mcf_base.amd64-m64-gcc42-nn $MCF_DIR/inp.in
diff --git a/generate_trace.sh b/generate_trace.sh
new file mode 100755
index 0000000..e043a22
--- /dev/null
+++ b/generate_trace.sh
@@ -0,0 +1,71 @@
+#!/bin/bash 
+
+source $TRACER_DIR/source.sh
+
+kill_descendant_processes() {
+    local pid="$1"
+    local and_self="${2:-false}"
+    if children="$(pgrep -P "$pid")"; then
+        for child in $children; do
+            kill_descendant_processes "$child" true
+        done
+    fi
+    if [[ "$and_self" == true ]]; then
+        echo "Killing $pid"
+        kill -INT "$pid"
+    fi
+}
+
+sigint()
+{
+   echo "signal INT received, script ending"
+   kill_descendant_processes $$
+   exit 0
+}
+trap sigint USR1
+
+APPLICATION=""
+READ_THE_REST=0
+for i in "$@"
+do
+  if [ "$READ_THE_REST" -eq "1" ]; then
+    APPLICATION="$APPLICATION $i"
+    continue
+  else
+    case $i in
+        -f=*|--enabler_file=*)
+        ENABLE_FILE="${i#*=}"
+        shift # past argument=value
+        continue
+        ;;
+        -o=*|--output_dir=*)
+        OUTPUT_DIR="${i#*=}"
+        shift # past argument=value
+        continue
+        ;;
+        *)
+        READ_THE_REST=1
+        APPLICATION="$i"
+        ;;    
+    esac
+  fi
+done
+
+if [ -d "$OUTPUT_DIR" ]; then
+  echo "Seems that directory already exist. Please rename/remove it."
+  return 1
+fi
+
+mkdir -p $OUTPUT_DIR
+echo "APPLICATION             = ${APPLICATION}"
+echo "OUTPUT_DIR              = ${OUTPUT_DIR}"
+echo "ENABLE_FILE             = ${ENABLE_FILE}"
+
+echo "run_tracer -t drcachesim -offline -outdir $OUTPUT_DIR -verbose 1 -enabler_filename $ENABLE_FILE -trace_after_instrs 1 -use_physical1 -- $APPLICATION " > $OUTPUT_DIR/cmd
+cat $OUTPUT_DIR/cmd
+echo Running...
+
+run_tracer -t drcachesim -offline -outdir $OUTPUT_DIR -verbose 1 -enabler_filename $ENABLE_FILE -trace_after_instrs 1 -- $APPLICATION & pid=!$
+echo $pid > /proc/page_tables
+
+wait
diff --git a/install.sh b/install.sh
new file mode 100755
index 0000000..83bfe70
--- /dev/null
+++ b/install.sh
@@ -0,0 +1,10 @@
+mkdir -p build && pushd build
+# Generate makefiles with CMake.  Pass in the path to your source directory.
+cmake 